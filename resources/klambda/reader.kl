(defun read-file (V7857) (let Bytelist (read-file-as-bytelist V7857) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) Bytelist) (lambda E (shen.print-residue (value shen.*residue*)))) (let Process (shen.process-sexprs S-exprs) Process))))

(defun shen.print-residue (V7858) (let Err (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V7858)))

(defun shen.nchars (V7863 V7864) (cond ((= 0 V7863) (do (pr " ..." (stoutput)) (abort))) ((= () V7864) (do (pr " ..." (stoutput)) (abort))) ((cons? V7864) (do (pr (n->string (hd V7864)) (stoutput)) (shen.nchars (- V7863 1) (tl V7864)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V7865) (let Stream (open V7865 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V7866 V7867 V7868) (cond ((= -1 V7867) V7868) (true (shen.read-file-as-bytelist-help V7866 (read-byte V7866) (cons V7867 V7868)))))

(defun read-file-as-string (V7869) (let Stream (open V7869 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V7870 V7871 V7872) (cond ((= -1 V7871) (do (close V7870) V7872)) (true (shen.rfas-h V7870 (read-byte V7870) (cn V7872 (n->string V7871))))))

(defun input (V7873) (eval-kl (read V7873)))

(defun input+ (V7874 V7875) (let Mono? (shen.monotype V7874) (let Input (read V7875) (if (= false (shen.typecheck Input (shen.rectify-type V7874))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V7874 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V7876) (cond ((cons? V7876) (map (lambda Z (shen.monotype Z)) V7876)) (true (if (variable? V7876) (simple-error (cn "input+ expects a monotype: not " (shen.app V7876 "
" shen.a))) V7876))))

(defun lineread (V7877) (shen.read-loop V7877 (shen.my-read-byte V7877) () (lambda X (shen.return? X))))

(defun read-from-string (V7878) (let Bytelist (shen.str->bytes V7878) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) (let Process (shen.process-sexprs S-exprs) Process))))

(defun read-from-string-unprocessed (V7879) (let Bytelist (shen.str->bytes V7879) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) S-exprs)))

(defun shen.str->bytes (V7880) (cond ((= "" V7880) ()) ((shen.+string? V7880) (cons (string->n (hdstr V7880)) (shen.str->bytes (tlstr V7880)))) (true (shen.f-error shen.str->bytes))))

(defun read (V7881) (hd (shen.read-loop V7881 (shen.my-read-byte V7881) () (lambda X (shen.whitespace? X)))))

(defun shen.my-read-byte (V7882) (if (shen.char-stinput? V7882) (string->n (shen.read-unit-string V7882)) (read-byte V7882)))

(defun shen.read-loop (V7887 V7888 V7889 V7890) (cond ((= 94 V7888) (simple-error "read aborted")) ((= -1 V7888) (if (empty? V7889) (simple-error "error: empty stream") (compile (lambda X (shen.<s-exprs> X)) V7889))) ((= 0 V7888) (shen.read-loop V7887 (shen.my-read-byte V7887) V7889 V7890)) (true (if (V7890 V7888) (let Parse (shen.try-parse V7889) (if (shen.nothing-doing? Parse) (shen.read-loop V7887 (shen.my-read-byte V7887) (append V7889 (cons V7888 ())) V7890) (do (shen.record-it V7889) Parse))) (shen.read-loop V7887 (shen.my-read-byte V7887) (append V7889 (cons V7888 ())) V7890)))))

(defun shen.try-parse (V7891) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) V7891) (lambda E shen.i-failed!)) (if (shen.nothing-doing? S-exprs) shen.i-failed! (shen.process-sexprs S-exprs))))

(defun shen.nothing-doing? (V7894) (cond ((= shen.i-failed! V7894) true) ((= () V7894) true) (true false)))

(defun shen.record-it (V7895) (set shen.*it* (shen.bytes->string V7895)))

(defun shen.bytes->string (V7896) (cond ((= () V7896) "") ((cons? V7896) (cn (n->string (hd V7896)) (shen.bytes->string (tl V7896)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V7897) (let Unpack&Expand (shen.unpackage&macroexpand V7897) (let FindArities (shen.find-arities Unpack&Expand) (let Types (shen.find-types Unpack&Expand) (map (lambda X (shen.process-applications X Types)) Unpack&Expand)))))

(defun shen.find-types (V7898) (cond ((and (cons? V7898) (and (cons? (tl V7898)) (= (hd V7898) (intern ":")))) (cons (hd (tl V7898)) (shen.find-types (tl (tl V7898))))) ((cons? V7898) (append (shen.find-types (hd V7898)) (shen.find-types (tl V7898)))) (true ())))

(defun shen.find-arities (V7901) (cond ((and (cons? V7901) (and (= define (hd V7901)) (and (cons? (tl V7901)) (and (cons? (tl (tl V7901))) (= { (hd (tl (tl V7901)))))))) (shen.store-arity (hd (tl V7901)) (shen.find-arity (hd (tl V7901)) 1 (tl (tl (tl V7901)))))) ((and (cons? V7901) (and (= define (hd V7901)) (cons? (tl V7901)))) (shen.store-arity (hd (tl V7901)) (shen.find-arity (hd (tl V7901)) 0 (tl (tl V7901))))) ((cons? V7901) (map (lambda Z (shen.find-arities Z)) V7901)) (true shen.skip)))

(defun shen.store-arity (V7902 V7903) (let ArityF (arity V7902) (if (= ArityF -1) (shen.execute-store-arity V7902 V7903) (if (= ArityF V7903) shen.skip (if (shen.sysfunc? V7902) (simple-error (shen.app V7902 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V7902 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V7902 V7903)))))))

(defun shen.execute-store-arity (V7904 V7905) (cond ((= 0 V7905) (put V7904 arity 0 (value *property-vector*))) (true (do (put V7904 arity V7905 (value *property-vector*)) (shen.update-lambdatable V7904 V7905)))))

(defun shen.update-lambdatable (V7906 V7907) (let LambdaTable (value shen.*lambdatable*) (let Lambda (eval-kl (shen.lambda-function (cons V7906 ()) V7907)) (let Insert (shen.assoc-> V7906 Lambda LambdaTable) (let Reset (set shen.*lambdatable* Insert) Reset)))))

(defun shen.lambda-function (V7910 V7911) (cond ((= 0 V7911) shen.skip) ((= 1 V7911) (let X (gensym Y) (cons lambda (cons X (cons (append V7910 (cons X ())) ()))))) (true (let X (gensym Y) (cons lambda (cons X (cons (shen.lambda-function (append V7910 (cons X ())) (- V7911 1)) ())))))))

(defun shen.assoc-> (V7921 V7922 V7923) (cond ((= () V7923) (cons (cons V7921 V7922) ())) ((and (cons? V7923) (and (cons? (hd V7923)) (= V7921 (hd (hd V7923))))) (cons (cons (hd (hd V7923)) V7922) (tl V7923))) ((cons? V7923) (cons (hd V7923) (shen.assoc-> V7921 V7922 (tl V7923)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V7938 V7939 V7940) (cond ((and (= 0 V7939) (and (cons? V7940) (= (hd V7940) ->))) 0) ((and (= 0 V7939) (and (cons? V7940) (= (hd V7940) <-))) 0) ((and (= 0 V7939) (cons? V7940)) (+ 1 (shen.find-arity V7938 0 (tl V7940)))) ((and (= 1 V7939) (and (cons? V7940) (= } (hd V7940)))) (shen.find-arity V7938 0 (tl V7940))) ((and (= 1 V7939) (cons? V7940)) (shen.find-arity V7938 1 (tl V7940))) ((= 1 V7939) (simple-error (cn "syntax error in " (shen.app V7938 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V7938 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V7941) (let Result (let Parseshen.<lsb> (shen.<lsb> V7941) (if (shen.parse-failure? Parseshen.<lsb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lsb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rsb> (shen.<rsb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rsb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rsb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (cons (shen.cons-form (shen.<-out Parseshen.<s-exprs1>)) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lrb> (shen.<lrb> V7941) (if (shen.parse-failure? Parseshen.<lrb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lrb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rrb> (shen.<rrb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rrb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rrb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (shen.add-sexpr (shen.<-out Parseshen.<s-exprs1>) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lcurly> (shen.<lcurly> V7941) (if (shen.parse-failure? Parseshen.<lcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<lcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons { (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rcurly> (shen.<rcurly> V7941) (if (shen.parse-failure? Parseshen.<rcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<rcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons } (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<bar> (shen.<bar> V7941) (if (shen.parse-failure? Parseshen.<bar>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<bar>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons bar! (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<semicolon> (shen.<semicolon> V7941) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<semicolon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ";") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V7941) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<equal> (shen.<equal> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<equal>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<equal>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":=") (shen.<-out Parseshen.<s-exprs>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V7941) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comma> (shen.<comma> V7941) (if (shen.parse-failure? Parseshen.<comma>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comma>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ",") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comment> (shen.<comment> V7941) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<atom> (shen.<atom> V7941) (if (shen.parse-failure? Parseshen.<atom>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<atom>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (shen.<-out Parseshen.<atom>) (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespaces> (shen.<whitespaces> V7941) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<whitespaces>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7941) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.add-sexpr (V7942 V7943) (cond ((and (cons? V7942) (and (= $ (hd V7942)) (and (cons? (tl V7942)) (= () (tl (tl V7942)))))) (append (explode (hd (tl V7942))) V7943)) (true (cons V7942 V7943))))

(defun shen.<lsb> (V7944) (let Result (if (shen.=hd? V7944 91) (let News7624 (shen.tls V7944) (shen.comb (shen.in-> News7624) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rsb> (V7945) (let Result (if (shen.=hd? V7945 93) (let News7626 (shen.tls V7945) (shen.comb (shen.in-> News7626) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs1> (V7946) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V7946) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs2> (V7947) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V7947) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.cons-form (V7949) (cond ((= () V7949) ()) ((and (cons? V7949) (and (cons? (tl V7949)) (and (cons? (tl (tl V7949))) (and (= () (tl (tl (tl V7949)))) (= (hd (tl V7949)) bar!))))) (cons cons (cons (hd V7949) (tl (tl V7949))))) ((and (cons? V7949) (and (cons? (tl V7949)) (and (cons? (tl (tl V7949))) (and (cons? (tl (tl (tl V7949)))) (= (hd (tl V7949)) bar!))))) (simple-error "misapplication of |
")) ((cons? V7949) (cons cons (cons (hd V7949) (cons (shen.cons-form (tl V7949)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V7950) (let Result (if (shen.=hd? V7950 40) (let News7630 (shen.tls V7950) (shen.comb (shen.in-> News7630) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rrb> (V7951) (let Result (if (shen.=hd? V7951 41) (let News7632 (shen.tls V7951) (shen.comb (shen.in-> News7632) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lcurly> (V7952) (let Result (if (shen.=hd? V7952 123) (let News7634 (shen.tls V7952) (shen.comb (shen.in-> News7634) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rcurly> (V7953) (let Result (if (shen.=hd? V7953 125) (let News7636 (shen.tls V7953) (shen.comb (shen.in-> News7636) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<bar> (V7954) (let Result (if (shen.=hd? V7954 124) (let News7638 (shen.tls V7954) (shen.comb (shen.in-> News7638) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<semicolon> (V7955) (let Result (if (shen.=hd? V7955 59) (let News7640 (shen.tls V7955) (shen.comb (shen.in-> News7640) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<colon> (V7956) (let Result (if (shen.=hd? V7956 58) (let News7642 (shen.tls V7956) (shen.comb (shen.in-> News7642) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comma> (V7957) (let Result (if (shen.=hd? V7957 44) (let News7644 (shen.tls V7957) (shen.comb (shen.in-> News7644) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<equal> (V7958) (let Result (if (shen.=hd? V7958 61) (let News7646 (shen.tls V7958) (shen.comb (shen.in-> News7646) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comment> (V7959) (let Result (let Parseshen.<singleline> (shen.<singleline> V7959) (if (shen.parse-failure? Parseshen.<singleline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<singleline>) shen.skip))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<multiline> (shen.<multiline> V7959) (if (shen.parse-failure? Parseshen.<multiline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<multiline>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<singleline> (V7960) (let Result (let Parseshen.<backslash> (shen.<backslash> V7960) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<shortnatters>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<backslash> (V7961) (let Result (if (shen.=hd? V7961 92) (let News7650 (shen.tls V7961) (shen.comb (shen.in-> News7650) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<shortnatters> (V7962) (let Result (let Parseshen.<shortnatter> (shen.<shortnatter> V7962) (if (shen.parse-failure? Parseshen.<shortnatter>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<shortnatter>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<shortnatters>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7962) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<shortnatter> (V7963) (let Result (if (shen.non-empty-stream? V7963) (let Byte (shen.hds V7963) (let News7653 (shen.tls V7963) (if (not (shen.return? Byte)) (shen.comb (shen.in-> News7653) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<returns> (V7964) (let Result (let Parseshen.<return> (shen.<return> V7964) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<return>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<return> (shen.<return> V7964) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<return>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<return> (V7965) (let Result (if (shen.non-empty-stream? V7965) (let Byte (shen.hds V7965) (let News7656 (shen.tls V7965) (if (shen.return? Byte) (shen.comb (shen.in-> News7656) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.return? (V7966) (element? V7966 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V7967) (let Result (let Parseshen.<backslash> (shen.<backslash> V7967) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<times> (shen.<times> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<times> (V7968) (let Result (if (shen.=hd? V7968 42) (let News7659 (shen.tls V7968) (shen.comb (shen.in-> News7659) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<longnatter> (V7969) (let Result (let Parseshen.<comment> (shen.<comment> V7969) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<times> (shen.<times> V7969) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<backslash>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V7969) (let News7661 (shen.tls V7969) (let Parseshen.<longnatter> (shen.<longnatter> News7661) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<atom> (V7970) (let Result (let Parseshen.<str> (shen.<str> V7970) (if (shen.parse-failure? Parseshen.<str>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<str>) (shen.<-out Parseshen.<str>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<number> (shen.<number> V7970) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<sym> (shen.<sym> V7970) (if (shen.parse-failure? Parseshen.<sym>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sym>) (if (= (shen.<-out Parseshen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.<-out Parseshen.<sym>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<sym> (V7971) (let Result (let Parseshen.<alpha> (shen.<alpha> V7971) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alpha>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alpha>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<alpha> (V7972) (let Result (if (shen.non-empty-stream? V7972) (let Byte (shen.hds V7972) (let News7665 (shen.tls V7972) (if (shen.alpha? Byte) (shen.comb (shen.in-> News7665) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.alpha? (V7973) (or (shen.lowercase? V7973) (or (shen.uppercase? V7973) (shen.misc? V7973))))

(defun shen.lowercase? (V7974) (and (>= V7974 97) (<= V7974 122)))

(defun shen.uppercase? (V7975) (and (>= V7975 65) (<= V7975 90)))

(defun shen.misc? (V7976) (element? V7976 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V7977) (let Result (let Parseshen.<alphanum> (shen.<alphanum> V7977) (if (shen.parse-failure? Parseshen.<alphanum>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alphanum>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alphanum>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7977) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<alphanum> (V7978) (let Result (let Parseshen.<alpha> (shen.<alpha> V7978) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alpha>) (shen.<-out Parseshen.<alpha>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<numeral> (shen.<numeral> V7978) (if (shen.parse-failure? Parseshen.<numeral>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<numeral>) (shen.<-out Parseshen.<numeral>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<numeral> (V7979) (let Result (if (shen.non-empty-stream? V7979) (let Byte (shen.hds V7979) (let News7669 (shen.tls V7979) (if (shen.digit? Byte) (shen.comb (shen.in-> News7669) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.digit? (V7980) (and (>= V7980 48) (<= V7980 57)))

(defun shen.<str> (V7981) (let Result (let Parseshen.<dbq> (shen.<dbq> V7981) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<dbq>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (let Parseshen.<dbq> (shen.<dbq> Parseshen.<strcontents>) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<dbq>) (shen.<-out Parseshen.<strcontents>)))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbq> (V7982) (let Result (if (shen.=hd? V7982 34) (let News7672 (shen.tls V7982) (shen.comb (shen.in-> News7672) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<strcontents> (V7983) (let Result (let Parseshen.<strc> (shen.<strc> V7983) (if (shen.parse-failure? Parseshen.<strc>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<strc>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<strcontents>) (cn (shen.<-out Parseshen.<strc>) (shen.<-out Parseshen.<strcontents>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7983) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<strc> (V7984) (let Result (let Parseshen.<control> (shen.<control> V7984) (if (shen.parse-failure? Parseshen.<control>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<control>) (shen.<-out Parseshen.<control>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<notdbq> (shen.<notdbq> V7984) (if (shen.parse-failure? Parseshen.<notdbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<notdbq>) (shen.<-out Parseshen.<notdbq>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<control> (V7985) (let Result (let Parseshen.<lowC> (shen.<lowC> V7985) (if (shen.parse-failure? Parseshen.<lowC>) (shen.parse-failure) (let Parseshen.<hash> (shen.<hash> Parseshen.<lowC>) (if (shen.parse-failure? Parseshen.<hash>) (shen.parse-failure) (let Parseshen.<integer> (shen.<integer> Parseshen.<hash>) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<semicolon> (shen.<semicolon> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<semicolon>) (n->string (shen.<-out Parseshen.<integer>))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<notdbq> (V7986) (let Result (if (shen.non-empty-stream? V7986) (let Byte (shen.hds V7986) (let News7677 (shen.tls V7986) (if (not (= Byte 34)) (shen.comb (shen.in-> News7677) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lowC> (V7987) (let Result (if (shen.=hd? V7987 99) (let News7679 (shen.tls V7987) (shen.comb (shen.in-> News7679) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<hash> (V7988) (let Result (if (shen.=hd? V7988 35) (let News7681 (shen.tls V7988) (shen.comb (shen.in-> News7681) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<number> (V7989) (let Result (let Parseshen.<minus> (shen.<minus> V7989) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (- 0 (shen.<-out Parseshen.<number>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<plus> (shen.<plus> V7989) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<e-number> (shen.<e-number> V7989) (if (shen.parse-failure? Parseshen.<e-number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<e-number>) (shen.<-out Parseshen.<e-number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<float> (shen.<float> V7989) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<float>) (shen.<-out Parseshen.<float>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V7989) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)))

(defun shen.<minus> (V7990) (let Result (if (shen.=hd? V7990 45) (let News7684 (shen.tls V7990) (shen.comb (shen.in-> News7684) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<plus> (V7991) (let Result (if (shen.=hd? V7991 43) (let News7686 (shen.tls V7991) (shen.comb (shen.in-> News7686) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<integer> (V7992) (let Result (let Parseshen.<digits> (shen.<digits> V7992) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-integer (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<digits> (V7993) (let Result (let Parseshen.<digit> (shen.<digit> V7993) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (let Parseshen.<digits> (shen.<digits> Parseshen.<digit>) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (cons (shen.<-out Parseshen.<digit>) (shen.<-out Parseshen.<digits>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<digit> (shen.<digit> V7993) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digit>) (cons (shen.<-out Parseshen.<digit>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<digit> (V7994) (let Result (if (shen.non-empty-stream? V7994) (let Byte (shen.hds V7994) (let News7690 (shen.tls V7994) (if (shen.digit? Byte) (shen.comb (shen.in-> News7690) (shen.byte->digit Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.byte->digit (V7995) (- V7995 48))

(defun shen.compute-integer (V7996) (shen.compute-integer-h (reverse V7996) 0))

(defun shen.compute-integer-h (V7999 V8000) (cond ((= () V7999) 0) ((cons? V7999) (+ (* (shen.expt 10 V8000) (hd V7999)) (shen.compute-integer-h (tl V7999) (+ V8000 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V8003 V8004) (cond ((= 0 V8004) 1) ((> V8004 0) (* V8003 (shen.expt V8003 (- V8004 1)))) (true (/ (shen.expt V8003 (+ V8004 1)) V8003))))

(defun shen.<float> (V8005) (let Result (let Parseshen.<integer> (shen.<integer> V8005) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<stop> (shen.<stop> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (+ (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<fraction>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<stop> (shen.<stop> V8005) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (shen.<-out Parseshen.<fraction>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<stop> (V8006) (let Result (if (shen.=hd? V8006 46) (let News7693 (shen.tls V8006) (shen.comb (shen.in-> News7693) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<fraction> (V8007) (let Result (let Parseshen.<digits> (shen.<digits> V8007) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-fraction (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-fraction (V8008) (shen.compute-fraction-h V8008 -1))

(defun shen.compute-fraction-h (V8011 V8012) (cond ((= () V8011) 0) ((cons? V8011) (+ (* (shen.expt 10 V8012) (hd V8011)) (shen.compute-fraction-h (tl V8011) (- V8012 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V8013) (let Result (let Parseshen.<float> (shen.<float> V8013) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<float>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<float>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V8013) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<log10> (V8014) (let Result (let Parseshen.<plus> (shen.<plus> V8014) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.<-out Parseshen.<log10>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<minus> (shen.<minus> V8014) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (- 0 (shen.<-out Parseshen.<log10>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V8014) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<lowE> (V8015) (let Result (if (shen.=hd? V8015 101) (let News7698 (shen.tls V8015) (shen.comb (shen.in-> News7698) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-E (V8016 V8017) (* V8016 (shen.expt 10 V8017)))

(defun shen.<whitespaces> (V8018) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V8018) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (let Parseshen.<whitespaces> (shen.<whitespaces> Parseshen.<whitespace>) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespaces>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V8018) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespace>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<whitespace> (V8019) (let Result (if (shen.non-empty-stream? V8019) (let Byte (shen.hds V8019) (let News7701 (shen.tls V8019) (if (shen.whitespace? Byte) (shen.comb (shen.in-> News7701) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.whitespace? (V8022) (cond ((= 32 V8022) true) ((= 13 V8022) true) ((= 10 V8022) true) ((= 9 V8022) true) (true false)))

(defun shen.unpackage&macroexpand (V8023) (cond ((= () V8023) ()) ((and (cons? V8023) (shen.packaged? (hd V8023))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V8023)) (tl V8023)))) ((cons? V8023) (let M (macroexpand (hd V8023)) (if (shen.packaged? M) (shen.unpackage&macroexpand (cons M (tl V8023))) (cons M (shen.unpackage&macroexpand (tl V8023)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V8026) (cond ((and (cons? V8026) (and (= package (hd V8026)) (and (cons? (tl V8026)) (cons? (tl (tl V8026)))))) true) (true false)))

(defun shen.unpackage (V8029) (cond ((and (cons? V8029) (and (= package (hd V8029)) (and (cons? (tl V8029)) (and (= null (hd (tl V8029))) (cons? (tl (tl V8029))))))) (tl (tl (tl V8029)))) ((and (cons? V8029) (and (= package (hd V8029)) (and (cons? (tl V8029)) (cons? (tl (tl V8029)))))) (let External! (eval (hd (tl (tl V8029)))) (let Package (shen.package-symbols (str (hd (tl V8029))) External! (tl (tl (tl V8029)))) (let RecordExternal (shen.record-external (hd (tl V8029)) External!) Package)))) (true (shen.f-error shen.unpackage))))

(defun shen.record-external (V8030 V8031) (let External (trap-error (get V8030 shen.external-symbols (value *property-vector*)) (lambda E ())) (put V8030 shen.external-symbols (union V8031 External) (value *property-vector*))))

(defun shen.package-symbols (V8036 V8037 V8038) (cond ((cons? V8038) (map (lambda X (shen.package-symbols V8036 V8037 X)) V8038)) ((shen.internal? V8038 V8036 V8037) (shen.intern-in-package V8036 V8038)) (true V8038)))

(defun shen.intern-in-package (V8039 V8040) (intern (@s V8039 (@s "." (str V8040)))))

(defun shen.internal? (V8041 V8042 V8043) (and (not (element? V8041 V8043)) (and (not (shen.sng? V8041)) (and (not (shen.dbl? V8041)) (and (symbol? V8041) (and (not (shen.sysfunc? V8041)) (and (not (variable? V8041)) (and (not (shen.internal-to-shen? (str V8041))) (not (shen.internal-to-P? V8042 (str V8041)))))))))))

(defun shen.internal-to-shen? (V8048) (cond ((and (shen.+string? V8048) (and (= "s" (hdstr V8048)) (and (shen.+string? (tlstr V8048)) (and (= "h" (hdstr (tlstr V8048))) (and (shen.+string? (tlstr (tlstr V8048))) (and (= "e" (hdstr (tlstr (tlstr V8048)))) (and (shen.+string? (tlstr (tlstr (tlstr V8048)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8048))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8048))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8048))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V8049) (element? V8049 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V8057 V8058) (cond ((and (= "" V8057) (and (shen.+string? V8058) (= "." (hdstr V8058)))) true) ((and (shen.+string? V8057) (and (shen.+string? V8058) (= (hdstr V8057) (hdstr V8058)))) (shen.internal-to-P? (tlstr V8057) (tlstr V8058))) (true false)))

(defun shen.process-applications (V8061 V8062) (cond ((element? V8061 V8062) V8061) ((and (cons? V8061) (shen.non-application? (hd V8061))) (shen.special-case (hd V8061) V8061 V8062)) ((cons? V8061) (shen.process-application (map (lambda Y (shen.process-applications Y V8062)) V8061) V8062)) (true V8061)))

(defun shen.non-application? (V8065) (cond ((= define V8065) true) ((= defun V8065) true) ((= synonyms V8065) true) ((shen.special? V8065) true) ((shen.extraspecial? V8065) true) (true false)))

(defun shen.special-case (V8070 V8071 V8072) (cond ((and (= lambda V8070) (and (cons? V8071) (and (= lambda (hd V8071)) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (= () (tl (tl (tl V8071))))))))) (cons lambda (cons (hd (tl V8071)) (cons (shen.process-applications (hd (tl (tl V8071))) V8072) ())))) ((and (= let V8070) (and (cons? V8071) (and (= let (hd V8071)) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (and (cons? (tl (tl (tl V8071)))) (= () (tl (tl (tl (tl V8071))))))))))) (cons let (cons (hd (tl V8071)) (cons (shen.process-applications (hd (tl (tl V8071))) V8072) (cons (shen.process-applications (hd (tl (tl (tl V8071)))) V8072) ()))))) ((and (= defun V8070) (and (cons? V8071) (and (= defun (hd V8071)) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (and (cons? (tl (tl (tl V8071)))) (= () (tl (tl (tl (tl V8071))))))))))) V8071) ((and (= define V8070) (and (cons? V8071) (and (= define (hd V8071)) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (= { (hd (tl (tl V8071))))))))) (cons define (cons (hd (tl V8071)) (cons { (shen.process-after-type (hd (tl V8071)) (tl (tl (tl V8071))) V8072))))) ((and (= define V8070) (and (cons? V8071) (and (= define (hd V8071)) (cons? (tl V8071))))) (cons define (cons (hd (tl V8071)) (map (lambda Y (shen.process-applications Y V8072)) (tl (tl V8071)))))) ((= synonyms V8070) (cons synonyms V8071)) ((and (= type V8070) (and (cons? V8071) (and (= type (hd V8071)) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (= () (tl (tl (tl V8071))))))))) (cons type (cons (shen.process-applications (hd (tl V8071)) V8072) (tl (tl V8071))))) ((and (= input+ V8070) (and (cons? V8071) (and (= input+ (hd V8071)) (and (cons? (tl V8071)) (and (cons? (tl (tl V8071))) (= () (tl (tl (tl V8071))))))))) (cons input+ (cons (hd (tl V8071)) (cons (shen.process-applications (hd (tl (tl V8071))) V8072) ())))) ((and (cons? V8071) (shen.special? (hd V8071))) (cons (hd V8071) (map (lambda Y (shen.process-applications Y V8072)) (tl V8071)))) ((and (cons? V8071) (shen.extraspecial? (hd V8071))) V8071) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V8075 V8076 V8077) (cond ((and (cons? V8076) (= } (hd V8076))) (cons } (map (lambda Y (shen.process-applications Y V8077)) (tl V8076)))) ((cons? V8076) (cons (hd V8076) (shen.process-after-type V8075 (tl V8076) V8077))) (true (simple-error (cn "missing } in " (shen.app V8075 "
" shen.a))))))

(defun shen.process-application (V8078 V8079) (cond ((cons? V8078) (let ArityF (arity (hd V8078)) (let N (length (tl V8078)) (if (element? V8078 V8079) V8078 (if (shen.shen-call? (hd V8078)) V8078 (if (shen.foreign? V8078) (shen.unpack-foreign V8078) (if (shen.fn-call? V8078) (shen.fn-call V8078) (if (shen.zero-place? V8078) V8078 (if (shen.undefined-f? (hd V8078) ArityF) (shen.simple-curry (cons (cons fn (cons (hd V8078) ())) (tl V8078))) (if (variable? (hd V8078)) (shen.simple-curry V8078) (if (shen.application? (hd V8078)) (shen.simple-curry V8078) (if (shen.partial-application*? (hd V8078) ArityF N) (shen.lambda-function V8078 (- ArityF N)) (if (shen.overapplication? (hd V8078) ArityF N) (shen.simple-curry (cons (cons fn (cons (hd V8078) ())) (tl V8078))) V8078))))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.unpack-foreign (V8080) (cond ((and (cons? V8080) (and (cons? (hd V8080)) (and (= foreign (hd (hd V8080))) (and (cons? (tl (hd V8080))) (= () (tl (tl (hd V8080)))))))) (cons (hd (tl (hd V8080))) (tl V8080))) (true (shen.f-error shen.unpack-foreign))))

(defun shen.foreign? (V8083) (cond ((and (cons? V8083) (and (cons? (hd V8083)) (and (= foreign (hd (hd V8083))) (and (cons? (tl (hd V8083))) (= () (tl (tl (hd V8083)))))))) true) (true false)))

(defun shen.zero-place? (V8086) (cond ((and (cons? V8086) (= () (tl V8086))) true) (true false)))

(defun shen.shen-call? (V8087) (and (symbol? V8087) (shen.internal-to-shen? (str V8087))))

(defun shen.internal-to-shen? (V8092) (cond ((and (shen.+string? V8092) (and (= "s" (hdstr V8092)) (and (shen.+string? (tlstr V8092)) (and (= "h" (hdstr (tlstr V8092))) (and (shen.+string? (tlstr (tlstr V8092))) (and (= "e" (hdstr (tlstr (tlstr V8092)))) (and (shen.+string? (tlstr (tlstr (tlstr V8092)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8092))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8092))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8092))))))))))))))) true) (true false)))

(defun shen.application? (V8097) (cond ((and (cons? V8097) (and (= protect (hd V8097)) (and (cons? (tl V8097)) (= () (tl (tl V8097)))))) false) ((and (cons? V8097) (and (= foreign (hd V8097)) (and (cons? (tl V8097)) (= () (tl (tl V8097)))))) false) (true (cons? V8097))))

(defun shen.undefined-f? (V8102 V8103) (cond ((= -1 V8103) (and (shen.lowercase-symbol? V8102) (not (element? V8102 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V8104) (and (symbol? V8104) (not (variable? V8104))))

(defun shen.simple-curry (V8105) (cond ((and (cons? V8105) (and (cons? (tl V8105)) (= () (tl (tl V8105))))) V8105) ((and (cons? V8105) (and (cons? (tl V8105)) (cons? (tl (tl V8105))))) (shen.simple-curry (cons (cons (hd V8105) (cons (hd (tl V8105)) ())) (tl (tl V8105))))) (true V8105)))

(defun function (V8106) (fn V8106))

(defun fn (V8107) (let LookUp (assoc V8107 (value shen.*lambdatable*)) (if (empty? LookUp) (simple-error (cn "fn: " (shen.app V8107 " is undefined
" shen.a))) (tl LookUp))))

(defun shen.fn-call? (V8110) (cond ((and (cons? V8110) (and (= fn (hd V8110)) (and (cons? (tl V8110)) (= () (tl (tl V8110)))))) true) ((and (cons? V8110) (and (= function (hd V8110)) (and (cons? (tl V8110)) (= () (tl (tl V8110)))))) true) (true false)))

(defun shen.fn-call (V8111) (cond ((and (cons? V8111) (and (= function (hd V8111)) (and (cons? (tl V8111)) (= () (tl (tl V8111)))))) (shen.fn-call (cons fn (tl V8111)))) ((and (cons? V8111) (and (= fn (hd V8111)) (and (cons? (tl V8111)) (= () (tl (tl V8111)))))) (let ArityF (arity (hd (tl V8111))) (if (= ArityF -1) V8111 (if (= ArityF 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V8111) ArityF))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V8112 V8113 V8114) (let Verdict (> V8113 V8114) (let Message (if (and Verdict (and (shen.loading?) (not (element? V8112 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V8112 "
" shen.a)) (stoutput)) shen.skip) Verdict)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V8119 V8120 V8121) (cond ((= -1 V8120) false) (true (let Verdict (< V8120 V8121) (let Message (if (and Verdict (shen.loading?)) (pr (shen.app V8119 (cn " might not like " (shen.app V8121 (cn " argument" (shen.app (if (= V8121 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) Verdict)))))

