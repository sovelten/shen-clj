(defun shen.shen->kl (V6565) (let KL (shen.shen->kl-h V6565) (shen.record-and-evaluate KL)))

(defun shen.record-and-evaluate (V6566) (cond ((and (cons? V6566) (and (= defun (hd V6566)) (and (cons? (tl V6566)) (and (cons? (tl (tl V6566))) (and (cons? (tl (tl (tl V6566)))) (= () (tl (tl (tl (tl V6566)))))))))) (let SysfuncChk (if (shen.sysfunc? (hd (tl V6566))) (simple-error (shen.app (hd (tl V6566)) " is not a legitimate function name
" shen.a)) shen.skip) (let Arity (shen.store-arity (hd (tl V6566)) (length (hd (tl (tl V6566))))) (let Record (shen.record-kl (hd (tl V6566)) V6566) (let Eval (eval-kl V6566) (shen.fn-print (hd (tl V6566)))))))) (true V6566)))

(defun shen.shen->kl-h (V6567) (cond ((and (cons? V6567) (and (= define (hd V6567)) (cons? (tl V6567)))) (shen.shendef->kldef (hd (tl V6567)) (tl (tl V6567)))) ((and (cons? V6567) (and (= defun (hd V6567)) (and (cons? (tl V6567)) (and (cons? (tl (tl V6567))) (and (cons? (tl (tl (tl V6567)))) (= () (tl (tl (tl (tl V6567)))))))))) V6567) ((and (cons? V6567) (and (= type (hd V6567)) (and (cons? (tl V6567)) (and (cons? (tl (tl V6567))) (= () (tl (tl (tl V6567)))))))) (cons type (cons (hd (tl V6567)) (cons (shen.rcons_form (hd (tl (tl V6567)))) ())))) ((and (cons? V6567) (and (= input+ (hd V6567)) (and (cons? (tl V6567)) (and (cons? (tl (tl V6567))) (= () (tl (tl (tl V6567)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V6567))) (tl (tl V6567))))) ((cons? V6567) (map (lambda Z (shen.shen->kl-h Z)) V6567)) (true V6567)))

(defun shen.shendef->kldef (V6568 V6569) (compile (lambda X (shen.<define> X)) (cons V6568 V6569)))

(defun shen.<define> (V6570) (let Result (let Parseshen.<name> (shen.<name> V6570) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (if (shen.=hd? Parseshen.<name> {) (let News6430 (shen.tls Parseshen.<name>) (let Parseshen.<signature> (shen.<signature> News6430) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News6431 (shen.tls Parseshen.<signature>) (let Parseshen.<rules> (shen.<rules> News6431) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<name> (shen.<name> V6570) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<name>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.shendef->kldef-h (V6571 V6572) (let Ps (map (lambda X (fst X)) V6572) (let Arity (shen.arity-chk V6571 Ps) (let FreeVarChk (map (lambda R (shen.free-var-chk V6571 R)) V6572) (let Unprotect (shen.unprotect V6572) (let KL (shen.factorise-code (shen.compile-to-kl V6571 Unprotect Arity)) KL))))))

(defun shen.unprotect (V6573) (cond ((tuple? V6573) (@p (shen.unprotect (fst V6573)) (shen.unprotect (snd V6573)))) ((and (cons? V6573) (and (= protect (hd V6573)) (and (cons? (tl V6573)) (= () (tl (tl V6573)))))) (shen.unprotect (hd (tl V6573)))) ((cons? V6573) (map (lambda Z (shen.unprotect Z)) V6573)) (true V6573)))

(defun shen.<name> (V6574) (let Result (if (shen.non-empty-stream? V6574) (let X (shen.hds V6574) (let News6433 (shen.tls V6574) (shen.comb (shen.in-> News6433) (if (and (symbol? X) (not (variable? X))) X (simple-error (shen.app X " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<signature> (V6575) (let Result (if (shen.non-empty-stream? V6575) (let X (shen.hds V6575) (let News6435 (shen.tls V6575) (let Parseshen.<signature> (shen.<signature> News6435) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (not (element? X (cons { (cons } ())))) (shen.comb (shen.in-> Parseshen.<signature>) (cons X (shen.<-out Parseshen.<signature>))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6575) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rules> (V6576) (let Result (let Parseshen.<rule> (shen.<rule> V6576) (if (shen.parse-failure? Parseshen.<rule>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<rule>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (cons (shen.linearise (shen.<-out Parseshen.<rule>)) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V6576) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.linearise (V6579) (cond ((tuple? V6579) (shen.linearise-h (fst V6579) (fst V6579) () (snd V6579))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V6592 V6593 V6594 V6595) (cond ((= () V6592) (@p V6593 V6595)) ((and (cons? V6592) (cons? (hd V6592))) (shen.linearise-h (append (hd V6592) (tl V6592)) V6593 V6594 V6595)) ((and (cons? V6592) (variable? (hd V6592))) (if (element? (hd V6592) V6594) (let Z (gensym V) (shen.linearise-h (tl V6592) (shen.rep-X (hd V6592) Z V6593) V6594 (cons where (cons (cons = (cons Z (cons (hd V6592) ()))) (cons V6595 ()))))) (shen.linearise-h (tl V6592) V6593 (cons (hd V6592) V6594) V6595))) ((cons? V6592) (shen.linearise-h (tl V6592) V6593 V6594 V6595)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V6596) (let Result (let Parseshen.<patterns> (shen.<patterns> V6596) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News6438 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6438) (let Action (shen.hds News6438) (let News6439 (shen.tls News6438) (if (shen.=hd? News6439 where) (let News6440 (shen.tls News6439) (if (shen.non-empty-stream? News6440) (let Guard (shen.hds News6440) (let News6441 (shen.tls News6440) (shen.comb (shen.in-> News6441) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6596) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News6442 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6442) (let Action (shen.hds News6442) (let News6443 (shen.tls News6442) (shen.comb (shen.in-> News6443) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6596) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News6444 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6444) (let Action (shen.hds News6444) (let News6445 (shen.tls News6444) (if (shen.=hd? News6445 where) (let News6446 (shen.tls News6445) (if (shen.non-empty-stream? News6446) (let Guard (shen.hds News6446) (let News6447 (shen.tls News6446) (shen.comb (shen.in-> News6447) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons (cons shen.choicepoint! (cons Action ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6596) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News6448 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6448) (let Action (shen.hds News6448) (let News6449 (shen.tls News6448) (shen.comb (shen.in-> News6449) (@p (shen.<-out Parseshen.<patterns>) (cons shen.choicepoint! (cons Action ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<patterns> (V6597) (let Result (let Parseshen.<pattern> (shen.<pattern> V6597) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (let Parseshen.<patterns> (shen.<patterns> Parseshen.<pattern>) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<patterns>) (cons (shen.<-out Parseshen.<pattern>) (shen.<-out Parseshen.<patterns>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6597) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern> (V6598) (let Result (if (shen.ccons? V6598) (let SynCons (shen.comb (shen.hds V6598) (shen.<-out V6598)) (let Parseshen.<constructor> (shen.<constructor> SynCons) (if (shen.parse-failure? Parseshen.<constructor>) (shen.parse-failure) (let Parseshen.<pattern1> (shen.<pattern1> Parseshen.<constructor>) (if (shen.parse-failure? Parseshen.<pattern1>) (shen.parse-failure) (let Parseshen.<pattern2> (shen.<pattern2> Parseshen.<pattern1>) (if (shen.parse-failure? Parseshen.<pattern2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<pattern2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V6598)) (cons (shen.<-out Parseshen.<constructor>) (cons (shen.<-out Parseshen.<pattern1>) (cons (shen.<-out Parseshen.<pattern2>) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V6598) (let SynCons (shen.comb (shen.hds V6598) (shen.<-out V6598)) (if (shen.=hd? SynCons vector) (let News6452 (shen.tls SynCons) (if (shen.=hd? News6452 0) (let News6453 (shen.tls News6452) (let Parseshen.<end> (shen.<end> News6453) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V6598)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V6598) (let X (shen.hds V6598) (let News6454 (shen.tls V6598) (if (cons? X) (shen.comb (shen.in-> News6454) (shen.constructor-error X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<simple-pattern> (shen.<simple-pattern> V6598) (if (shen.parse-failure? Parseshen.<simple-pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<simple-pattern>) (shen.<-out Parseshen.<simple-pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<constructor> (V6599) (let Result (if (shen.non-empty-stream? V6599) (let C (shen.hds V6599) (let News6456 (shen.tls V6599) (if (shen.constructor? C) (shen.comb (shen.in-> News6456) C) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.constructor? (V6600) (element? V6600 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V6601) (simple-error (shen.app V6601 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V6602) (let Result (if (shen.non-empty-stream? V6602) (let X (shen.hds V6602) (let News6458 (shen.tls V6602) (if (= X _) (shen.comb (shen.in-> News6458) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V6602) (let X (shen.hds V6602) (let News6459 (shen.tls V6602) (if (not (element? X (cons -> (cons <- ())))) (shen.comb (shen.in-> News6459) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern1> (V6603) (let Result (let Parseshen.<pattern> (shen.<pattern> V6603) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<pattern2> (V6604) (let Result (let Parseshen.<pattern> (shen.<pattern> V6604) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.fn-print (V6605) (let V (absvector 2) (let Print (address-> V 0 shen.printF) (let Named (address-> Print 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V6605) ")")))))) Named))))

(defun shen.printF (V6606) (<-address V6606 1))

(defun shen.arity-chk (V6611 V6612) (cond ((and (cons? V6612) (= () (tl V6612))) (length (hd V6612))) ((and (cons? V6612) (and (cons? (tl V6612)) (= (length (hd V6612)) (length (hd (tl V6612)))))) (shen.arity-chk V6611 (tl V6612))) (true (simple-error (cn "arity error in " (shen.app V6611 "
" shen.a))))))

(defun shen.free-var-chk (V6613 V6614) (cond ((tuple? V6614) (shen.free-variable-error-message V6613 (shen.find-free-vars (shen.extract-vars (fst V6614)) (snd V6614)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V6615 V6616) (if (empty? V6616) shen.skip (do (pr (cn "free variables in " (shen.app V6615 ":" shen.a)) (stoutput)) (do (map (lambda X (pr (cn " " (shen.app X "" shen.a)) (stoutput))) V6616) (do (nl 1) (abort))))))

(defun shen.extract-vars (V6619) (cond ((variable? V6619) (cons V6619 ())) ((cons? V6619) (union (shen.extract-vars (hd V6619)) (shen.extract-vars (tl V6619)))) (true ())))

(defun shen.find-free-vars (V6624 V6625) (cond ((and (cons? V6625) (and (= protect (hd V6625)) (and (cons? (tl V6625)) (= () (tl (tl V6625)))))) ()) ((and (cons? V6625) (and (= let (hd V6625)) (and (cons? (tl V6625)) (and (cons? (tl (tl V6625))) (and (cons? (tl (tl (tl V6625)))) (= () (tl (tl (tl (tl V6625)))))))))) (union (shen.find-free-vars V6624 (hd (tl (tl V6625)))) (shen.find-free-vars (cons (hd (tl V6625)) V6624) (hd (tl (tl (tl V6625))))))) ((and (cons? V6625) (and (= lambda (hd V6625)) (and (cons? (tl V6625)) (and (cons? (tl (tl V6625))) (= () (tl (tl (tl V6625)))))))) (shen.find-free-vars (cons (hd (tl V6625)) V6624) (hd (tl (tl V6625))))) ((cons? V6625) (union (shen.find-free-vars V6624 (hd V6625)) (shen.find-free-vars V6624 (tl V6625)))) ((shen.free-variable? V6625 V6624) (cons V6625 ())) (true ())))

(defun shen.free-variable? (V6626 V6627) (and (variable? V6626) (not (element? V6626 V6627))))

(defun shen.record-kl (V6628 V6629) (put V6628 shen.source V6629 (value *property-vector*)))

(defun shen.compile-to-kl (V6630 V6631 V6632) (let Parameters (shen.parameters V6632) (let Body (shen.scan-body V6630 (shen.kl-body V6631 Parameters)) (let Defun (cons defun (cons V6630 (cons Parameters (cons (shen.cond-form Body) ())))) Defun))))

(defun shen.parameters (V6633) (cond ((= 0 V6633) ()) (true (cons (gensym V) (shen.parameters (- V6633 1))))))

(defun shen.cond-form (V6636) (cond ((and (cons? V6636) (and (cons? (hd V6636)) (and (= true (hd (hd V6636))) (and (cons? (tl (hd V6636))) (= () (tl (tl (hd V6636)))))))) (hd (tl (hd V6636)))) (true (cons cond V6636))))

(defun shen.scan-body (V6645 V6646) (cond ((= () V6646) (cons (cons true (cons (cons shen.f-error (cons V6645 ())) ())) ())) ((and (cons? V6646) (shen.choicepoint? (hd V6646))) (shen.choicepoint V6645 (gensym Freeze) (gensym Result) (hd V6646) (tl V6646))) ((and (cons? V6646) (and (cons? (hd V6646)) (and (= true (hd (hd V6646))) (and (cons? (tl (hd V6646))) (= () (tl (tl (hd V6646)))))))) (cons (hd V6646) ())) ((cons? V6646) (cons (hd V6646) (shen.scan-body V6645 (tl V6646)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V6653) (cond ((and (cons? V6653) (and (cons? (tl V6653)) (and (cons? (hd (tl V6653))) (and (= shen.choicepoint! (hd (hd (tl V6653)))) (and (cons? (tl (hd (tl V6653)))) (and (= () (tl (tl (hd (tl V6653))))) (= () (tl (tl V6653))))))))) true) (true false)))

(defun shen.choicepoint (V6669 V6670 V6671 V6672 V6673) (cond ((and (cons? V6672) (and (cons? (tl V6672)) (and (cons? (hd (tl V6672))) (and (cons? (tl (hd (tl V6672)))) (and (cons? (hd (tl (hd (tl V6672))))) (and (= fail-if (hd (hd (tl (hd (tl V6672)))))) (and (cons? (tl (hd (tl (hd (tl V6672)))))) (and (cons? (tl (tl (hd (tl (hd (tl V6672))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V6672)))))))) (and (= () (tl (tl (hd (tl V6672))))) (and (= () (tl (tl V6672))) (= V6669 (hd (tl (hd (tl (hd (tl V6672)))))))))))))))))) (cons (cons true (cons (cons let (cons V6670 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V6672)))))) V6673)) ())) (cons (cons if (cons (hd V6672) (cons (cons let (cons V6671 (cons (hd (tl (tl (hd (tl (hd (tl V6672))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V6672)))))) (cons V6671 ())) (cons (cons thaw (cons V6670 ())) (cons V6671 ())))) ())))) (cons (cons thaw (cons V6670 ())) ())))) ())))) ())) ())) ((and (cons? V6672) (and (cons? (tl V6672)) (and (cons? (hd (tl V6672))) (and (cons? (tl (hd (tl V6672)))) (and (= () (tl (tl (hd (tl V6672))))) (= () (tl (tl V6672)))))))) (cons (cons true (cons (cons let (cons V6670 (cons (cons freeze (cons (cons cond (shen.scan-body V6669 V6673)) ())) (cons (cons if (cons (hd V6672) (cons (cons let (cons V6671 (cons (hd (tl (hd (tl V6672)))) (cons (cons if (cons (cons = (cons V6671 (cons (cons fail ()) ()))) (cons (cons thaw (cons V6670 ())) (cons V6671 ())))) ())))) (cons (cons thaw (cons V6670 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V6675 V6676 V6677) (cond ((= V6675 V6677) V6676) ((cons? V6677) (let Rep (shen.rep-X V6675 V6676 (hd V6677)) (if (= Rep (hd V6677)) (cons (hd V6677) (shen.rep-X V6675 V6676 (tl V6677))) (cons Rep (tl V6677))))) (true V6677)))

(defun shen.kl-body (V6678 V6679) (map (lambda R (shen.triple-stack () (fst R) V6679 (snd R))) V6678))

(defun shen.triple-stack (V6688 V6689 V6690 V6691) (cond ((and (= () V6689) (and (= () V6690) (and (cons? V6691) (and (= where (hd V6691)) (and (cons? (tl V6691)) (and (cons? (tl (tl V6691))) (= () (tl (tl (tl V6691)))))))))) (shen.triple-stack (cons (hd (tl V6691)) V6688) () () (hd (tl (tl V6691))))) ((and (= () V6689) (= () V6690)) (cons (shen.rectify-test (reverse V6688)) (cons V6691 ()))) ((and (cons? V6689) (and (cons? V6690) (variable? (hd V6689)))) (shen.triple-stack V6688 (tl V6689) (tl V6690) (shen.beta (hd V6689) (hd V6690) V6691))) ((and (cons? V6689) (and (cons? (hd V6689)) (and (cons? (tl (hd V6689))) (and (cons? (tl (tl (hd V6689)))) (and (= () (tl (tl (tl (hd V6689))))) (cons? V6690)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V6689))) (cons (hd V6690) ())) V6688) (cons (hd (tl (hd V6689))) (cons (hd (tl (tl (hd V6689)))) (tl V6689))) (cons (cons (shen.op1 (hd (hd V6689))) (cons (hd V6690) ())) (cons (cons (shen.op2 (hd (hd V6689))) (cons (hd V6690) ())) (tl V6690))) (shen.beta (hd V6689) (hd V6690) V6691))) ((and (cons? V6689) (cons? V6690)) (shen.triple-stack (cons (cons = (cons (hd V6689) (cons (hd V6690) ()))) V6688) (tl V6689) (tl V6690) V6691)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V6694) (cond ((= () V6694) true) ((and (cons? V6694) (= () (tl V6694))) (hd V6694)) ((and (cons? V6694) (cons? (tl V6694))) (cons and (cons (hd V6694) (cons (shen.rectify-test (tl V6694)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V6704 V6705 V6706) (cond ((= V6704 V6706) V6705) ((and (cons? V6706) (and (= lambda (hd V6706)) (and (cons? (tl V6706)) (and (cons? (tl (tl V6706))) (and (= () (tl (tl (tl V6706)))) (= V6704 (hd (tl V6706)))))))) V6706) ((and (cons? V6706) (and (= let (hd V6706)) (and (cons? (tl V6706)) (and (cons? (tl (tl V6706))) (and (cons? (tl (tl (tl V6706)))) (and (= () (tl (tl (tl (tl V6706))))) (= V6704 (hd (tl V6706))))))))) (cons let (cons (hd (tl V6706)) (cons (shen.beta (hd (tl V6706)) V6705 (hd (tl (tl V6706)))) (tl (tl (tl V6706))))))) ((cons? V6706) (map (lambda V (shen.beta V6704 V6705 V)) V6706)) (true V6706)))

(defun shen.op1 (V6709) (cond ((= cons V6709) hd) ((= @s V6709) hdstr) ((= @p V6709) fst) ((= @v V6709) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V6712) (cond ((= cons V6712) tl) ((= @s V6712) tlstr) ((= @p V6712) snd) ((= @v V6712) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V6715) (cond ((= cons V6715) cons?) ((= @s V6715) shen.+string?) ((= @p V6715) tuple?) ((= @v V6715) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V6716) (cond ((= "" V6716) false) (true (string? V6716))))

(defun shen.+vector? (V6717) (cond ((= V6717 (vector 0)) false) (true (vector? V6717))))

(defun factorise (V6720) (cond ((= + V6720) (set shen.*factorise?* true)) ((= - V6720) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V6721) (cond ((and (cons? V6721) (and (= defun (hd V6721)) (and (cons? (tl V6721)) (and (cons? (tl (tl V6721))) (and (cons? (tl (tl (tl V6721)))) (and (cons? (hd (tl (tl (tl V6721))))) (and (= cond (hd (hd (tl (tl (tl V6721)))))) (and (= () (tl (tl (tl (tl V6721))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V6721)) (cons (hd (tl (tl V6721))) (cons (shen.vertical (hd (tl (tl V6721))) (tl (hd (tl (tl (tl V6721))))) (cons shen.f-error (cons (hd (tl V6721)) ()))) ()))))) (true V6721)))

(defun shen.vertical (V6734 V6735 V6736) (cond ((and (cons? V6735) (and (cons? (hd V6735)) (and (= true (hd (hd V6735))) (and (cons? (tl (hd V6735))) (= () (tl (tl (hd V6735)))))))) (hd (tl (hd V6735)))) ((= () V6735) V6736) ((and (cons? V6735) (and (cons? (hd V6735)) (and (cons? (hd (hd V6735))) (and (= and (hd (hd (hd V6735)))) (and (cons? (tl (hd (hd V6735)))) (and (cons? (tl (tl (hd (hd V6735))))) (and (= () (tl (tl (tl (hd (hd V6735)))))) (and (cons? (tl (hd V6735))) (= () (tl (tl (hd V6735)))))))))))) (let Before+After (shen.split-cases (hd (tl (hd (hd V6735)))) V6735 ()) (shen.branch (hd (tl (hd (hd V6735)))) V6734 Before+After V6736))) ((and (cons? V6735) (and (cons? (hd V6735)) (and (cons? (tl (hd V6735))) (= () (tl (tl (hd V6735))))))) (cons if (cons (hd (hd V6735)) (cons (hd (tl (hd V6735))) (cons (shen.vertical V6734 (tl V6735) V6736) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V6741 V6742 V6743) (cond ((and (cons? V6742) (and (cons? (hd V6742)) (and (cons? (hd (hd V6742))) (and (= and (hd (hd (hd V6742)))) (and (cons? (tl (hd (hd V6742)))) (and (cons? (tl (tl (hd (hd V6742))))) (and (= () (tl (tl (tl (hd (hd V6742)))))) (and (cons? (tl (hd V6742))) (and (= () (tl (tl (hd V6742)))) (= V6741 (hd (tl (hd (hd V6742)))))))))))))) (shen.split-cases (hd (tl (hd (hd V6742)))) (tl V6742) (cons (cons (hd (tl (tl (hd (hd V6742))))) (tl (hd V6742))) V6743))) ((and (cons? V6742) (and (cons? (hd V6742)) (and (cons? (tl (hd V6742))) (and (= () (tl (tl (hd V6742)))) (= V6741 (hd (hd V6742))))))) (shen.split-cases (hd (hd V6742)) (tl V6742) (cons (cons true (tl (hd V6742))) V6743))) (true (cons (reverse V6743) (cons V6742 ())))))

(defun shen.branch (V6744 V6745 V6746 V6747) (cond ((and (cons? V6746) (and (cons? (tl V6746)) (= () (tl (tl V6746))))) (let Else (shen.else V6745 (hd (tl V6746)) V6747) (let Then (shen.then V6744 V6745 (hd V6746) Else) (cons if (cons V6744 (cons Then (cons Else ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V6748 V6749 V6750) (let Else (shen.vertical V6748 V6749 V6750) (if (shen.inline? Else) Else (shen.procedure-call V6748 Else))))

(defun shen.procedure-call (V6751 V6752) (let F (gensym shen.else) (let Used (shen.remove-if-unused V6751 V6752) (let KL (cons defun (cons F (cons Used (cons V6752 ())))) (let EvalKL (eval-kl KL) (let Record (shen.record-kl F KL) (cons F Used)))))))

(defun shen.remove-if-unused (V6759 V6760) (cond ((= () V6759) ()) ((cons? V6759) (if (shen.occurs? (hd V6759) V6760) (cons (hd V6759) (shen.remove-if-unused (tl V6759) V6760)) (shen.remove-if-unused (tl V6759) V6760))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V6761 V6762 V6763 V6764) (shen.horizontal (shen.selectors V6761 V6763) V6762 V6763 V6764))

(defun shen.horizontal (V6773 V6774 V6775 V6776) (cond ((= () V6773) (shen.vertical V6774 V6775 V6776)) ((cons? V6773) (let V (gensym V) (cons let (cons V (cons (hd V6773) (cons (shen.horizontal (tl V6773) (cons V V6774) (subst V (hd V6773) V6775) V6776) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V6781 V6782) (cond ((and (cons? V6781) (and (cons? (tl V6781)) (and (= () (tl (tl V6781))) (shen.constructor? (shen.op (hd V6781)))))) (let Op (shen.op (hd V6781)) (let Hd (cons (shen.op1 Op) (tl V6781)) (let Tl (cons (shen.op2 Op) (tl V6781)) (let RptedHd? (shen.rpted? Hd V6782) (let RptedTl? (shen.rpted? Tl V6782) (if (and RptedHd? RptedTl?) (cons Hd (cons Tl ())) (if RptedHd? (cons Hd ()) (if RptedTl? (cons Tl ()) ()))))))))) (true ())))

(defun shen.rpted? (V6783 V6784) (> (occurrences V6783 V6784) 1))

(defun shen.inline? (V6785) (cond ((cons? V6785) (and (atom? (hd V6785)) (shen.inline? (tl V6785)))) (true (atom? V6785))))

(defun shen.op (V6788) (cond ((= cons? V6788) cons) ((= shen.+string? V6788) @s) ((= shen.+vector? V6788) @v) ((= tuple? V6788) @p) (true shen.skip)))

